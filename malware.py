#!/usr/bin/env python

"""
Dan O'Day, Purdue University
CNIT581 Cyber Forensics of Malware

Given path (or list of paths) to folder(s) with malware samples, create malware sample objects with parsed data
"""

__author__ = "Dan O'Day"
__credits__ = ["Dan O'Day", "Sam Liles"]
__license__ = "GNU General Public License"
__version__ = "0.1"
__maintainer__ = "Dan O'Day"
__email__ = "doday@purdue.edu"
__status__ = "Development"


import re
import subprocess
from pefile.pefile import PE
# from pefile.peutils import is_probably_packed  # threshold too low, inaccurate
from fileurl import get_file_names_and_urls


class MalwareSample():
    """
    Class for PE32 binary malware sample objects. Each object has properties related to parsing the binary.
    """
    def __init__(self, path_to_sample):
        """
        MalwareSample() initialization. Takes file path to malware sample as input.

        :param path_to_sample: File path to PE32 malware sample binary
        """
        self.file_path = path_to_sample
        self.pe = PE(path_to_sample)
        self.packed = False
        self.section_names = []
        self.imported_symbols = []
        self.exported_symbols = []
        self.file_names = []
        self.urls = []
        self.strings = []
        self.excluded = []
        self.initiate_process()

        # after processing is finished, conserve memory by ditching the file itself
        self.pe = None

    def __str__(self):
        return 'MalwareSample object from %s' % self.file_path

    def __repr__(self):
        return 'MalwareSample(%s)' % self.file_path

    def check_if_packed(self):
        """
        Checks if binary is packed. Currently simplistic, only looks for 'UPX' string in section names.
        """
        # if is_probably_packed(self.pe):  # threshold too low, inaccurate
            # print '\t', "***MALWARE SAMPLE SUSPECTED OF BEING PACKED***"
            # self.packed = True

        for s in self.section_names:
            if 'UPX' in s:  # currently only checking for UPX and only finds low-hanging fruit
                print '\t', "***MALWARE SAMPLE SUSPECTED OF BEING PACKED***"
                self.packed = True
                break  # no need to go through the rest

    def extract_sections(self):
        """
        Extracts section names from malware sample.
        """
        print '\t', "extracting section names..."
        for section in self.pe.sections:
            print '\t\t', section.Name
            self.section_names.append(section.Name)

    def extract_symbols(self):
        """
        Extracts imported and exported symbols from malware sample.
        """
        # imported symbols
        print '\t', "extracting imported symbols..."
        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            for imported_symbol in entry.imports:
                print '\t\t', imported_symbol.name
                self.imported_symbols.append(imported_symbol.name)

        # exported symbols
        try:
            print '\t', "extracting exported symbols..."
            for e in self.pe.DIRECTORY_ENTRY_EXPORT.symbols:
                print '\t\t', e.name
                self.exported_symbols.append(e.name)
        except AttributeError:
            print '\t\t', "no symbols exported"

    def extract_fns_and_urls(self):
        """
        Extracts file names and url's from binary.

        URL extraction comes from pefile library and is horrible, so this is reimplemented within extract_strings()
        """
        files, urls = get_file_names_and_urls(self.file_path)

        """
        The function that extracts file names generates a list of tuples where the first item is the file category
        assigned by the function and second item of each tuple is a list of file names corresponding to that category.

        Example output of 'files' list:

        [ ('Binary',   ['core_x86.bin', 'dropper_x86.bin']),
		('Web Page', ['gate.php']),
		('Library',  ['IPHLPAPI.DLL', 'WININET.dll']) ]

        key to below code:
        ---------------------
        ft = file type
        fnl = file name list
        fn = file name

        TODO: RFI: Is this function ignoring files with a file extension not identified in the function?
        """

        # file names
        print '\t', "extracting file names..."
        for ft, fnl in files:
            print '\t\t', ft, "files"
            for fn in fnl:
                print '\t\t\t', fn
                self.file_names.append(fn)

        # urls
        for u in urls:
            self.urls.append(u)

    def extract_strings(self):
        """
        Extracts strings using command line (must have strings command in system path on shell of system running this)
        """
        print '\t', 'extracting strings...'
        ps = subprocess.Popen(['strings', '-a', self.file_path], stdout=subprocess.PIPE)  # use -a to bypass libbfd
        output = ps.communicate()[0]
        for line in output.splitlines():
            self.strings.append(line)

        # remove URLs from strings list that weren't caught by pefile (lots)
        for elem in self.strings:
            pattern = re.compile(r'((mailto\:|(news|(ht|f)tp(s?))\://){1}\S+)', re.IGNORECASE)
            match = re.search(pattern, elem)
            if match and len(elem) > 6:  # len(c.it) = 4 <- false positive
                self.urls.append(elem)

        # remove urls from strings that have been appended to self.urls, eliminate duplicates in self.urls
        self.strings = [s for s in self.strings if s not in self.urls]
        self.urls = list(set(self.urls))
        print '\t', "extracting urls..."  # a lie, but from user output perspective it is easiest to display this here
        for url in self.urls:
            print '\t\t', url

    def populate_excluded(self):
        """
        Populates list of excluded items and removes items from strings list
        """
        self.excluded.extend(self.section_names)
        self.excluded.extend(self.imported_symbols)
        self.excluded.extend(self.exported_symbols)
        self.excluded.extend(self.file_names)
        self.excluded.extend(self.urls)

        strings_to_remove = []
        for s in self.strings:
            for xs in self.excluded:
                if xs in s:
                    strings_to_remove.append(s)

        self.strings = [s for s in self.strings if s not in strings_to_remove]


    def unpack(self):
        """
        Unpacks binary - not implemented
        """
        raise NotImplementedError

    def initiate_process(self):
        """
        Internal initiation method used to stack all initialization methods in required order
        """
        self.extract_sections()
        self.check_if_packed()
        self.extract_symbols()
        self.extract_fns_and_urls()
        self.extract_strings()

        if self.packed:
            pass  # unpack() method call goes here, rerun initiate_process() on unpacked binary

        self.populate_excluded()